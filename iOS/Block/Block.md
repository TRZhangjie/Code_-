本文来自`Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法`一书中

第37条: 理解 "块" 这一概念

###  理解 "块" 这一概念

--- 

#### 块的基础知识

块与函数类似，只不过是直接定义在一个函数里的，和定义它的那个函数共享同一个范围内的东西。块用 "^" 符号来表示，后面跟着一对花括号，括号里面是块的实现代码。

例如,下面就是个简单的块:

    ^{
        //Block implementation here
    }
    
块其实就是个值，而且自有其相关类型。与int、float 或 OC 对象一样，也可以把这块赋给变量，然后像使用其他变量那样使用它。块类型的语法与函数指针近似。

##### 无参无返回值:

    void (^someBlock)() = ^{
        //Block implementation here
    };
    
这段代码定义了一个名为 someBlock 的变量。块类型的语法结构如下:

    return_type (^type_name)(parameters)
    
##### 有参有返回值:

    int (^addBlock)(int a, int b) = ^(int a, inta){
        return a + b;
    }
    
定义好了之后，就可以向函数那般使用。

    int result = addBlock(2, 5); //< result = 7;
    

块的强大之处是: 在声明它的范围里，所有变量都可以为其所捕获。也就是说，那个范围里的全部变量，在块里依然可用。

比如，下面这段代码所定义的块，就使用了块以外的变量:
    
    int additional = 5;
    int (^addBlock)(int a, int b) = ^(int a, int b){
        return a + b + additional;
    }
    int result = addBlock(2, 5); //< result = 12
    
默认情况下，为块所捕获的变量，是不可以再块里修改的。

在本例中，假如 块内 的代码改动了 additional 变量的值，那么编辑器就会报错(或者给出警告)。不过，声明变量的时候可以加上 __block 修饰符，这样就可以在块内修改了。


#### 块的内部结构

每个 OC 对象都占据某个内存区域。因为实例变量的个数及对象所包含的关联数据互不相同，所以每个对象所占据的内存区域也有大有小。

块本身也是对象，在存放块对象的内存区域中，首个变量是指向 Class 对象的指针，该指针叫做 isa。其余内存里含有块对象正常运转所需的各种信息。

![image](http://note.youdao.com/favicon.ico)

在内存布局中，最重要的就是 invoke 变量，这是个函数指针，指向块的实现代码。函数原型至少要接受一个 void* 型的参数，此参数代表块。

descriptor 变量是指向结构体的指针，每个块里都包含此结构体，其中声明了块对象的总体大小，还声明了 copy 和 dispose 这两个辅助函数所对应的函数指针。


#### 全局块、栈块及堆块

定义块的时候，其所占的内存区域是分配在栈中的。这就是说，块只在定义它的那个范围内有效。

例如下面这段代码就有危险:

    void (^block)();
    
    if(/*some condition*/){
        block = ^{
            NSlog(@"Block A");
        };
    } else {
        block = ^{
            NSlog(@"Block B");
        };
    };
    block();

定义在if 及 else 语句中的两个块都分配在栈中。编辑器会给每个块分配好栈内存，然而等离开了相应的范围之后，编译器有可能把分配给块的内存覆盖掉。于是，这两个块只能保证在对应的if 或者 else 语句范围内有效。这样写出来的代码可以编译，但是运行起来时而正确时而错误。

为解决此问题，可给块对象发送 copy 消息以拷贝之。这样的话，就可以把块从栈复制到堆了。拷贝后的块，可以再定义它的那个范围之外使用。而且，一旦复制到堆上，块就成了带引用计数器的对象了。后续的复制操作都不会真的执行复制，只是递增块对象的引用计数。如果不使用这个快，那就将其释放，在ARC环境中会自动释放，而手动管理引用计数器则需要自己来调用 release 方法。当引用计数器降为0后，"分配在堆上的块"(heap blcok)会像其他对象一样，为系统所回收。而 "分配在栈上的块(stack blcok)"则无须明确释放，因为栈区存本来就会自动回收，刚才那个代码之所以危险，原因在此。

除了 "栈块" 和 "堆块" 之外，还有一个类叫做 "全局块(global block)"。这种块不会捕捉任何状态(比如外围的变量等)，运行期也无须有状态来参与。块所使用的整个内存区域，在编译期已经完全确定了，因此，全局块可以声明在全局内存里，而不需要在每次用到的时候于栈中创建。另外，全局块操作是个空操作，因为全局块绝不能为系统所回收。这个快实例上级相当于单例。

    void (^globalBlck) = ^{
        NSlog(@"This is a Global Block");
    }
    
由于运行该块所需的全部信息都能在编译期确定，所以可以把它做成全局块。这完全是种优化技术: 若把如此简单的块当成复杂的块来处理，那么就会在辅助及丢弃该块时执行一些无谓的操作。

#### 小结

- 块是C、C++、0C、JavaScript中的语法闭包。
- 块可以接受参数，也可返回值
- 块可以分配在栈或者堆上，也可以是全局的。分配在栈上的快可拷贝到堆里，这样的话，就和标准的 OC 对象了，具备引用计数了。
 
 

