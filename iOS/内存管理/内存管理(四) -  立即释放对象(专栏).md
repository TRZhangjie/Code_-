[CSDN](http://blog.csdn.net/Blog751196085/article/category/7319390)

[有道云]()


## 专栏 - 立即释放对象

以下源代码会引起编译器警告。
```
id __weak obj = [[NSObject alloc] init];
```
由于编译器判断 生成并持有的对象不能继续持有。那么附有 `__unsafe_unretained` 修饰符的变量又如何呢？

```
id __unsafe_unretained obj = [[NSObject alloc] init];
```
与 `__weak` 修饰符完全相同，编译器判断生成并持有的对象不能继续持有，而发出警告。

那么其底层具体实现又是如何呢?

```
<!--编译器模拟代码-->
id  obj = objc_msgSend(NSObject, @selector(alloc));
obj_msgSend(obj, @selector(init));
objc_release(obj);
```
`objc_release` 函数立即释放了生成并持有的对象， 这样该对象的悬垂指针被赋值给变量 `obj`中。

那么如果最初不赋值变量又会如何呢?想 下面的源代码在MRC时必定会发送内存泄漏。

```
[[NSObject alloc] init];
```

由于源代码不使用返回值的对象，所以编译器发出警告。
`warning ： expression result unused [-Wnunsed-value] [[NSObject alloc] init]`

可以像下面这样通过向 `void` 转型来避免发生警告。

```
(void)[[NSObject alloc] init];
```
不管是否转换为 `void`，该源码都会转换为以下形式

```
id  tmp = objc_msgSend(NSObject, @selector(alloc));
obj_msgSend(tmp, @selector(init));
objc_release(tmp);
```
虽然没有指定赋值变量，但与赋值给附有 `__unsafe_unretained` 修饰符变量的源代码完全相同。由于不能继续生成并持有的对象，所以编译器生成了立即调用了 `objc_release` 函数的源代码。而由于ARC的处理，这样的源代码也不会造成内存泄漏。

另外，能调用被立即释放的对象的实例方法吗?

```(void)[[[NSObject alloc] init] hash];```

源码如下:

```
id tmp = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(tmp, @selector(init));
objc_msgSend(tmp, @selector(hash));
objc_release(tmp);
```
在调用了生成并持有对象的实例方法后，该对象被释放。看来 '由编译器进行内存管理' 这句话是正确的。

